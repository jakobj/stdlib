import sim;
import std;

template<pint N; pint data[N]; pint W>
defproc check_sink(chan?(int<W>) I)
{
  int<W> x, y;
  int i;
  chp {
    *[ i := 0;
       *[ i < N -> I?x;
                   [([]k:N: i=k -> y:= data[k];
                                   [ x = y -> skip
                                     [] else -> log ("ASSERTION failed, value mismatch; expected: ", y, "%x (0x", y, "); got: ", x, "%x (0x", x, ")")
                                   ]
                   )];
                   i := i + 1
        ]
     ]
  }
}

defproc test_pow() {
    (i:9: {std::pow(i, 1) = i};)
    (i:9: {std::pow(i, 2) = i*i};)
    (i:9: {std::pow(i, 3) = i*i*i};)
}

defproc test_ceil_log2() {
    {std::ceil_log2(1) = 0};
    {std::ceil_log2(3) = 2};
    {std::ceil_log2(5) = 3};
    (i:9: {std::ceil_log2(std::pow(2, i)) = i};)
}

defproc test_max() {
    (i:9: {std::max(i, 10) = 10};)
    (i:9: {std::max(i, 0) = i};)
}

defproc test_min() {
    (i:9: {std::min(i, 10) = i};)
    (i:9: {std::min(i, 0) = 0};)
}

defproc dut_repeat (chan?(int<2>) in; chan!(int<4>) out) {
    int<2> x;
    chp {
      *[ in?x; out!std::bit::repeat<2, 2>(x) ]
    }
}

defproc test_repeat() {
    sim::source_seq<2, false, 3, {0,1,2}> src;
    check_sink<3, {0, 5, 10}, 4> snk;
    dut_repeat dut;
    dut.in = src.O;
    snk.I = dut.out;
}

defproc dut_sign_extend (chan?(int<3>) in; chan!(int<4>) out) {
    int<3> x;
    chp {
    *[ in?x; out!std::bit::sign_extend<3, 4>(x) ]
    }
}

defproc test_sign_extend() {
    // first set of three numbers tests whether zeros are correctly extended,
    // second set tests same for leading ones
    sim::source_seq<3, false, 6, {0,1,2,4,5,6}> src;
    check_sink<6, {0, 1, 2, 12, 13, 14}, 4> snk;
    dut_sign_extend dut;
    dut.in = src.O;
    snk.I = dut.out;
}

defproc dut_rol (chan?(int<3>) in; chan!(int<3>) out) {
    int<3> x;
    chp {
        *[ in?x; out!std::bit::rol<3>(x) ]
    }
}

defproc test_rol() {
    sim::source_seq<3, false, 6, {0,1,2,4,5,6}> src;
    check_sink<6, {0, 2, 4, 1, 3, 5}, 3> snk;
    dut_rol dut;
    dut.in = src.O;
    snk.I = dut.out;
}

defproc dut_ror (chan?(int<3>) in; chan!(int<3>) out) {
    int<3> x;
    int<3> y;
    chp {
    *[ in?x; out!std::bit::ror<3>(x) ]
    }
}

defproc test_ror() {
    sim::source_seq<3, false, 6, {0,1,2,4,5,6}> src;
    check_sink<6, {0, 4, 1, 2, 6, 3}, 3> snk;
    dut_ror dut;
    dut.in = src.O;
    snk.I = dut.out;
}

template<pint W; pint N; pint taps[N]>
defproc dut_fib_lfsr (chan!(int<W>) out) {
    int<W> state;
    int period;
    chp {
      period := 0;
      state := 4;
      *[ period = 0 | state != 4 -> state := std::fib_lfsr<W, N, taps>(state); period := period + 1 ];
      out!period
    }
}

defproc test_fib_lsfr() {
    // uses some polynomials from here
    // https://en.wikipedia.org/wiki/Linear-feedback_shift_register#Example_polynomials_for_maximal_LFSRs
    // to test for correct period
    check_sink<1, {7}, 3> snk0;
    dut_fib_lfsr<3, 2, {0, 1}> dut0;
    snk0.I = dut0.out;

    check_sink<1, {15}, 4> snk1;
    dut_fib_lfsr<4, 2, {0, 1}> dut1;
    snk1.I = dut1.out;

    check_sink<1, {255}, 8> snk2;
    dut_fib_lfsr<8, 4, {0, 2, 3, 4}> dut2;
    snk2.I = dut2.out;
}
