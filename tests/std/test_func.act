import sim;
import std;

template<pint N; pint data[N]; pint W>
defproc check_sink(chan?(int<W>) I)
{
  int<W> x, y;
  int i;
  chp {
    *[ i := 0;
       *[ i < N -> I?x;
                   [([]k:N: i=k -> y:= data[k];
                                   [ x = y -> skip
                                     [] else -> log ("ASSERTION failed, value mismatch; expected: ", y, "%x (0x", y, "); got: ", x, "%x (0x", x, ")")
                                   ]
                   )];
                   i := i + 1
        ]
     ]
  }
}

defproc adder(chan?(int) A, B; chan!(int) C)
{
    int a, b;
    chp {
      *[ A?a, B?b; C!(a+b) ]
    }
}

defproc test_adder() {
    adder dut;
    sim::source_seq<32, false, 3, {3,5,2}> s1(dut.A);
    sim::source_seq<32, false, 3, {7,9,3}> s2(dut.B);
    check_sink<3, {10, 14, 5}, 32> sx(dut.C);
}

defproc test_pow() {
    (i:9: {std::pow(i, 1) = i};)
    (i:9: {std::pow(i, 2) = i*i};)
    (i:9: {std::pow(i, 3) = i*i*i};)
}

defproc test_ceil_log2() {
    {std::ceil_log2(1) = 0};
    {std::ceil_log2(3) = 2};
    {std::ceil_log2(5) = 3};
    (i:9: {std::ceil_log2(std::pow(2, i)) = i};)
}

defproc test_max() {
    (i:9: {std::max(i, 10) = 10};)
    (i:9: {std::max(i, 0) = i};)
}

defproc test_min() {
    (i:9: {std::min(i, 10) = i};)
    (i:9: {std::min(i, 0) = 0};)
}

defproc dut_repeat (chan?(int<2>) in; chan!(int<4>) out) {
    int<2> x;
    chp {
      *[ in?x; out!std::bit::repeat<2, 2>(x) ]
    }
}

defproc test_repeat() {
    sim::source_seq<2, false, 3, {0,1,2}> src;
    check_sink<3, {0, 5, 10}, 4> snk;
    dut_repeat dut;
    dut.in = src.O;
    snk.I = dut.out;
}

defproc dut_sign_extend (chan?(int<3>) in; chan!(int<4>) out) {
    int<3> x;
    int<4> y;
    chp {
    *[ in?x; out!std::bit::sign_extend<3, 4>(x) ]
    }
}

defproc test_sign_extend() {
    // first set of three numbers tests whether zeros are correctly extended,
    // second set tests same for leading ones
    sim::source_seq<3, false, 6, {0,1,2,4,5,6}> src;
    check_sink<6, {0, 1, 2, 12, 13, 14}, 4> snk;
    dut_sign_extend dut;
    dut.in = src.O;
    snk.I = dut.out;
}
